package com.vgu.cs.engine.dao;

import com.vgu.cs.common.config.VConfig;
import com.vgu.cs.common.logger.VLogger;
import com.vgu.cs.common.util.CollectionUtils;
import com.vgu.cs.engine.entity.omop.PostgreSqlEntity;
import com.vgu.cs.engine.util.SqlUtils;
import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.logging.log4j.Logger;

import java.lang.reflect.Field;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public abstract class PostgreSqlDao<T extends PostgreSqlEntity> {
    
    private static final Logger LOGGER = VLogger.getLogger(PostgreSqlDao.class);
    private static final Map<String, BasicDataSource> DATA_SOURCE_MAP = new ConcurrentHashMap<>();
    public final String keyField;
    private final Class<T> _clazz;
    private final String _instanceName;
    
    public PostgreSqlDao(Class<T> clazz, String instanceName, String keyField) {
        this.keyField = keyField;
        _clazz = clazz;
        _instanceName = instanceName;
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    public Connection getConnection() throws SQLException {
        return _getDataSource().getConnection();
    }
    
    public PreparedStatement preparedStatementWithAutoGeneratedKeys(String sql, Object... objects) throws SQLException {
        try (Connection connection = getConnection()) {
            PreparedStatement ps = connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
            if (CollectionUtils.isNullOrEmpty(objects)) {
                return ps;
            }
            _fillPlaceholders(ps, objects);
            
            return ps;
        }
    }
    
    public List<T> selectAll(String sql, Object... objects) {
        try (Connection connection = getConnection()) {
            PreparedStatement ps = connection.prepareStatement(sql);
            if (!CollectionUtils.isNullOrEmpty(objects)) {
                _fillPlaceholders(ps, objects);
            }
            
            ResultSet rs = ps.executeQuery();
            List<T> result = _deserializeAll(rs);
            
            ps.close();
            rs.close();
            
            return result;
        } catch (SQLException | IllegalAccessException | InstantiationException e) {
            LOGGER.error(e.getMessage(), e);
            return new ArrayList<>();
        }
    }
    
    public List<Map<String, Object>> selectColumns(String sql, Object... objects) {
        try (Connection connection = getConnection()) {
            PreparedStatement ps = connection.prepareStatement(sql);
            if (!CollectionUtils.isNullOrEmpty(objects)) {
                _fillPlaceholders(ps, objects);
            }
            
            ResultSet rs = ps.executeQuery();
            List<Map<String, Object>> result = _deserializeColumns(rs);
            
            ps.close();
            rs.close();
            
            return result;
        } catch (SQLException e) {
            LOGGER.error(e.getMessage(), e);
            return new ArrayList<>();
        }
    }
    
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Private
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    private BasicDataSource _getDataSource() {
        if (DATA_SOURCE_MAP.containsKey(_instanceName)) {
            return DATA_SOURCE_MAP.get(_instanceName);
        }
        
        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setDriverClassName(VConfig.INSTANCE.getString(PostgreSqlDao.class, "driverClassName", ""));
        dataSource.setUrl(VConfig.INSTANCE.getString(PostgreSqlDao.class, "url", ""));
        dataSource.setUsername(VConfig.INSTANCE.getString(PostgreSqlDao.class, "userName", ""));
        dataSource.setPassword(VConfig.INSTANCE.getString(PostgreSqlDao.class, "password", ""));
        DATA_SOURCE_MAP.put(_instanceName, dataSource);
        
        return dataSource;
    }
    
    private void _fillPlaceholders(PreparedStatement ps, Object[] objects) throws SQLException {
        for (int i = 0; i < objects.length; i++) {
            ps.setObject(i + 1, objects[i]);
        }
    }
    
    private List<T> _deserializeAll(ResultSet rs) throws SQLException, IllegalAccessException, InstantiationException {
        if (!rs.isBeforeFirst()) {
            return new ArrayList<>();
        }
        
        List<T> ret = new ArrayList<>();
        while (rs.next()) {
            T object = _clazz.newInstance();
            
            Field[] fields = object.getClass().getDeclaredFields();
            for (Field field : fields) {
                String fieldName = field.getName();
                if (!_hasColumn(rs, fieldName)) {
                    continue;
                }
                Class<?> fieldType = field.getType();
                field.set(object, _getFieldValue(fieldType, fieldName, rs));
            }
            ret.add(object);
        }
        
        return ret;
    }
    
    private List<Map<String, Object>> _deserializeColumns(ResultSet rs) throws SQLException {
        if (!rs.isBeforeFirst()) {
            return new ArrayList<>();
        }
        
        List<Map<String, Object>> ret = new ArrayList<>();
        while (rs.next()) {
            Map<String, Object> object = new HashMap<>();
            ResultSetMetaData metaData = rs.getMetaData();
            
            for (int i = 1; i <= metaData.getColumnCount(); i++) {
                String fieldTypeName = SqlUtils.toJavaClassName(metaData.getColumnType(i));
                String fieldName = metaData.getColumnName(i);
                object.put(fieldName, _getFieldValue(fieldTypeName, fieldName, rs));
            }
            ret.add(object);
        }
        
        return ret;
    }
    
    private Object _getFieldValue(Class<?> fieldType, String fieldName, ResultSet resultSet) throws SQLException {
        return _getFieldValue(fieldType.getSimpleName(), fieldName, resultSet);
    }
    
    private Object _getFieldValue(String fieldTypeName, String fieldName, ResultSet resultSet) throws SQLException {
        if ("Integer".equals(fieldTypeName) || "int".equals(fieldTypeName)) {
            return resultSet.getInt(fieldName);
        } else if ("Long".equals(fieldTypeName) || "long".equals(fieldTypeName)) {
            return resultSet.getLong(fieldName);
        } else if ("Double".equals(fieldTypeName) || "double".equals(fieldTypeName)) {
            return resultSet.getDouble(fieldName);
        } else if ("Float".equals(fieldTypeName) || "float".equals(fieldTypeName)) {
            return resultSet.getFloat(fieldName);
        } else if ("Short".equals(fieldTypeName) || "short".equals(fieldTypeName)) {
            return resultSet.getShort(fieldName);
        } else if ("String".equals(fieldTypeName)) {
            return resultSet.getString(fieldName);
        } else if ("sql.Timestamp".equals(fieldTypeName)) {
            return SqlUtils.timestampToString(resultSet.getTimestamp(fieldName));
        } else if ("sql.Date".equals(fieldTypeName)) {
            return SqlUtils.dateToString(resultSet.getDate(fieldName));
        }
        return null;
    }
    
    private boolean _hasColumn(ResultSet resultSet, String columnName) throws SQLException {
        ResultSetMetaData metaData = resultSet.getMetaData();
        for (int i = 1; i <= metaData.getColumnCount(); i++) {
            if (columnName.equals(metaData.getColumnName(i))) {
                return true;
            }
        }
        return false;
    }
}
