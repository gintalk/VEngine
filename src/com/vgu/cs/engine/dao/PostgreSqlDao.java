package com.vgu.cs.engine.dao;

/*
 * Copyright (c) 2012-2016 by Zalo Group.
 * All Rights Reserved.
 *
 * @author namnh16 on 03/03/2021
 */

import com.vgu.cs.common.config.VConfig;
import com.vgu.cs.common.logger.VLogger;
import com.vgu.cs.common.util.CollectionUtils;
import org.apache.commons.dbcp2.BasicDataSource;
import org.apache.logging.log4j.Logger;

import java.lang.reflect.Field;
import java.sql.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public abstract class PostgreSqlDao<T> {

    private static final Logger LOGGER = VLogger.getLogger(PostgreSqlDao.class);
    private static final Map<String, BasicDataSource> DATA_SOURCE_MAP = new ConcurrentHashMap<>();
    private final Class<T> _clazz;
    private final String _instanceName;

    public PostgreSqlDao(Class<T> clazz, String instanceName) {
        _clazz = clazz;
        _instanceName = instanceName;
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    public Connection getConnection() throws SQLException {
        return _getDataSource().getConnection();
    }

    public void closeConnection(Connection connection) throws SQLException {
        connection.close();
    }

    public PreparedStatement prepareStatement(String sql, Object... objects) throws SQLException {
        PreparedStatement ps = getConnection().prepareStatement(sql);
        if (CollectionUtils.isNullOrEmpty(objects)) {
            return ps;
        }
        _fillPlaceholders(ps, objects);

        return ps;
    }

    public PreparedStatement preparedStatementWithAutoGeneratedKeys(String sql, Object... objects) throws SQLException {
        PreparedStatement ps = getConnection().prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);
        if (CollectionUtils.isNullOrEmpty(objects)) {
            return ps;
        }
        _fillPlaceholders(ps, objects);

        return ps;
    }

    public List<T> selectAll(String sql, Object... objects) {
        try {
            PreparedStatement ps = prepareStatement(sql, objects);
            ResultSet rs = ps.executeQuery();

            return _deserializeAll(rs);
        } catch (SQLException | IllegalAccessException | InstantiationException e) {
            LOGGER.error(e.getMessage(), e);
            return new ArrayList<>();
        }
    }

    public List<Map<String, Object>> selectColumns(String sql, Object... objects) {
        try {
            PreparedStatement ps = prepareStatement(sql, objects);
            ResultSet rs = ps.executeQuery();

            return _deserializeColumns(rs);
        } catch (SQLException e) {
            LOGGER.error(e.getMessage(), e);
            return new ArrayList<>();
        }
    }

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // Private
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    private BasicDataSource _getDataSource() {
        if (DATA_SOURCE_MAP.containsKey(_instanceName)) {
            return DATA_SOURCE_MAP.get(_instanceName);
        }

        BasicDataSource dataSource = new BasicDataSource();
        dataSource.setDriverClassName(VConfig.INSTANCE.getString(PostgreSqlDao.class, "driverClassName", ""));
        dataSource.setUrl(VConfig.INSTANCE.getString(PostgreSqlDao.class, "url", ""));
        dataSource.setUsername(VConfig.INSTANCE.getString(PostgreSqlDao.class, "userName", ""));
        dataSource.setPassword(VConfig.INSTANCE.getString(PostgreSqlDao.class, "password", ""));
        DATA_SOURCE_MAP.put(_instanceName, dataSource);

        return dataSource;
    }

    private void _fillPlaceholders(PreparedStatement ps, Object[] objects) throws SQLException {
        for (int i = 0; i < objects.length; i++) {
            ps.setObject(i + 1, objects[i]);
        }
    }

    private List<T> _deserializeAll(ResultSet rs) throws SQLException, IllegalAccessException, InstantiationException {
        if (!rs.isBeforeFirst()) {
            return new ArrayList<>();
        }

        List<T> ret = new ArrayList<>();
        while (rs.next()) {
            T object = _clazz.newInstance();

            Field[] fields = object.getClass().getDeclaredFields();
            for (Field field : fields) {
                String fieldName = field.getName();
                if (!_hasColumn(rs, fieldName)) {
                    continue;
                }
                Class<?> fieldType = field.getType();
                field.set(object, _getFieldValue(fieldType, fieldName, rs));
            }
            ret.add(object);
        }

        return ret;
    }

    private List<Map<String, Object>> _deserializeColumns(ResultSet rs) throws SQLException {
        if (!rs.isBeforeFirst()) {
            return new ArrayList<>();
        }

        List<Map<String, Object>> ret = new ArrayList<>();
        while (rs.next()) {
            Map<String, Object> object = new HashMap<>();
            ResultSetMetaData metaData = rs.getMetaData();

            for (int i = 1; i <= metaData.getColumnCount(); i++) {
                String fieldTypeName = metaData.getColumnTypeName(i);
                String fieldName = metaData.getColumnName(i);
                object.put(fieldName, _getFieldValue(fieldTypeName, fieldName, rs));
            }
            ret.add(object);
        }

        return ret;
    }

    private Object _getFieldValue(Class<?> fieldType, String fieldName, ResultSet resultSet) throws SQLException{
        return _getFieldValue(fieldType.getSimpleName(), fieldName, resultSet);
    }

    private Object _getFieldValue(String fieldTypeName, String fieldName, ResultSet resultSet) throws SQLException {
        if ("Integer".equals(fieldTypeName) || "int".equals(fieldTypeName)) {
            return resultSet.getInt(fieldName);
        } else if ("Long".equals(fieldTypeName) || "long".equals(fieldTypeName)) {
            return resultSet.getLong(fieldName);
        } else if ("Double".equals(fieldTypeName) || "double".equals(fieldTypeName)) {
            return resultSet.getDouble(fieldName);
        } else if ("Float".equals(fieldTypeName) || "float".equals(fieldTypeName)) {
            return resultSet.getFloat(fieldName);
        } else if ("Short".equals(fieldTypeName) || "short".equals(fieldTypeName)) {
            return resultSet.getShort(fieldName);
        } else if ("String".equals(fieldTypeName)) {
            return resultSet.getString(fieldName);
        }
        return null;
    }

    private boolean _hasColumn(ResultSet resultSet, String columnName) throws SQLException {
        ResultSetMetaData metaData = resultSet.getMetaData();
        for (int i = 1; i <= metaData.getColumnCount(); i++) {
            if (columnName.equals(metaData.getColumnName(i))) {
                return true;
            }
        }
        return false;
    }
}
